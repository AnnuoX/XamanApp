import { isString, isObject, has, get } from 'lodash';

import parserFactory from '@common/libs/ledger/parser';
import { TransactionJSONType, TransactionsType } from '@common/libs/ledger/types';

import { ApiService, LoggerService, SocketService } from '@services';

// locale
import Localize from '@locale';

// types
import {
    PayloadType,
    MetaType,
    ApplicationType,
    PatchSuccessType,
    PatchRejectType,
    PayloadReferenceType,
} from './types';

// errors
import errors from './errors';

// create logger
const logger = LoggerService.createLogger('Payload');

export class Payload {
    meta: MetaType;
    application: ApplicationType;
    payload: PayloadReferenceType;
    transaction: TransactionsType;

    /**
     * get payload object from payload UUID or payload Json
     * @param args
     */
    static async from(args: string | PayloadType): Promise<Payload> {
        const payload = new Payload();
        // TODO: better error handling

        // if Payload UUID passed then fetch the payload from backend
        if (isString(args)) {
            await payload.fetch(args);
        } else if (isObject(args)) {
            // if not,  assign it to the class
            payload.assign(args);
        } else {
            throw new Error('invalid args applied, only string or object');
        }

        return payload;
    }

    /**
     * build payload from inside the app
     * @param TxJson Ledger format TXJson
     */
    static build(TxJson: TransactionJSONType): Promise<Payload> {
        const payload = {} as Payload;

        payload.application = {
            name: 'XUMM',
            description: 'Description about XUMM',
            disabled: 0,
            uuidv4: '',
            icon_url: 'https://xumm-cdn.imgix.net/app-logo/91348bab-73d2-489a-bb7b-a8dba83e40ff.png',
        };

        payload.meta = {
            submit: true,
            generated: true,
        };

        payload.payload = {
            tx_type: TxJson.TransactionType,
            tx_destination: '',
            tx_destination_tag: null,
            request_json: TxJson,
        };

        return Payload.from(payload);
    }

    /**
     * Get JSON transaction ledger format of payload
     */
    get TxJson(): TransactionJSONType {
        return this.payload.request_json;
    }

    /**
     *  Assign payload object to class
     * @param object
     */
    assign = (object: PayloadType) => {
        Object.assign(this, object);
        try {
            this.transaction = parserFactory(this.TxJson);
        } catch (e) {
            throw new Error(e.string());
        }
    };

    /**
     * fetch payload by UUID from backend
     * @param uuid
     */
    fetch = (uuid: string) => {
        return new Promise((resolve, reject) => {
            ApiService.payload
                .get(uuid)
                .then((res: any) => {
                    if (get(res, 'response.resolved_at')) {
                        return reject(new Error(Localize.t('payload.payloadAlreadyResolved')));
                    }

                    if (get(res, 'meta.expired')) {
                        return reject(new Error(Localize.t('payload.payloadExpired')));
                    }

                    this.assign(res);

                    return resolve(true);
                })
                .catch((err: any) => {
                    logger.debug('Fetch error', err);

                    if (has(err, 'code')) {
                        const errorMessage = get(errors, err.code);
                        return reject(new Error(errorMessage));
                    }

                    if (has(err, 'error')) {
                        const { error } = err;
                        if (has(error, 'code')) {
                            const errorMessage = get(errors, error.code);

                            return reject(new Error(errorMessage));
                        }

                        return reject(
                            new Error(Localize.t('payload.unexpectedErrorOccurred', { reference: error.reference })),
                        );
                    }
                    return reject(new Error(Localize.t('global.unexpectedErrorOccurred')));
                });
        });
    };

    /**
     * patch the payload to the backend
     * @param permission push permission
     */
    patch = (patch: PatchSuccessType | PatchRejectType) => {
        // if payload generated by xumm then don't patch to the backend
        if (this.meta.generated) return;

        ApiService.payload.patch(this.meta.uuid, patch).catch((e: any) => {
            logger.debug('Patch error', e);
        });
    };

    /**
     * quick hack for refactoring the object
     * @param transaction
     */
    refactorTransaction = (transaction: TransactionsType) => {
        this.transaction = transaction;
    };

    /**
     * check if we need to submit the tx to the ledger
     */
    shouldSubmit = (): boolean => {
        return this.meta.submit && this.payload.tx_type !== 'SignIn' && !this.meta.multisign;
    };

    /**
     * reject the payload
     */
    reject = () => {
        if (!this.meta.generated) {
            const rejectPatch = {
                reject: true,
                dispatched: {
                    to: SocketService.node,
                    nodetype: SocketService.chain,
                },
            };
            ApiService.payload.patch(this.meta.uuid, rejectPatch).catch((e: any) => {
                logger.debug('Payload patch reject error', e);
            });
        }
    };
}
